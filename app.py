import streamlit as st
import torch
import soundfile as sf
import torchaudio
from torchaudio.transforms import Resample
import audioseal
import pyttsx3 
import sys
import csv
import datetime
import random
import os
import io # Needed for in-memory file handling

# --- 1. Load AI Models ---
@st.cache_resource
def load_models():
    """Loads AudioSeal models and initializes TTS engine"""
    print("Loading AudioSeal models...")
    try:
        generator = audioseal.AudioSeal.load_generator("audioseal_wm_16bits")
        detector = audioseal.AudioSeal.load_detector("audioseal_detector_16bits")
        print("Models loaded.")
    except Exception as e:
        print(f"Error loading AudioSeal models: {e}")
        return None, None, None
    
    print("Initializing TTS engine...")
    try:
        tts_engine = pyttsx3.init()
        print("TTS engine initialized.")
    except Exception as e:
        print(f"Error initializing TTS engine: {e}")
        return generator, detector, None

    return generator, detector, tts_engine

# Load all models at the start
generator, detector, tts_engine = load_models()

# --- 2. Core Logic (Our Functions) ---
def preprocess_audio(wav, sample_rate):
    """Converts any wav to the required 16kHz, mono, 3D tensor format."""
    model_sample_rate = 16000
    
    if wav.ndim == 2:
        wav = wav.mean(axis=1) # Convert to mono
    wav_tensor = torch.tensor(wav, dtype=torch.float32)
    wav_tensor = wav_tensor.reshape(1, 1, -1) # Reshape to 3D

    if sample_rate != model_sample_rate:
        resampler = Resample(orig_freq=sample_rate, new_freq=model_sample_rate)
        wav_tensor = resampler(wav_tensor)
        
    return wav_tensor

# --- 3. Streamlit UI Layout ---
st.set_page_config(page_title="AudioSeal Watermarking", layout="wide")
st.title("ðŸ”Š AI Audio Generation & Watermarking Pipeline")

# Check if models loaded successfully
if generator is None or detector is None:
    st.error("Fatal Error: Could not load AudioSeal models. Check console.")
    st.stop()
if tts_engine is None:
    st.error("Fatal Error: Could not load Text-to-Speech (pyttsx3) engine.")
    st.stop()

# --- Create the Tabs ---
tab1, tab2, tab3 = st.tabs(["STEP 1: Generate Audio", "STEP 2: Embed Watermark", "STEP 3: Detect Watermark"])
GENERATED_FILE = "generated_audio.wav"
WATERMARKED_FILE = "watermarked_song.wav"

# --- TAB 1: GENERATE AUDIO ---
with tab1:
    st.header("Generate AI Speech (TTS)")
    st.info(f"This tool uses the `pyttsx3` offline library to generate speech. The output will be saved as `{GENERATED_FILE}`.")

    text_to_generate = st.text_area("Enter text to generate:", "Hello, this is a test of the audio generation and watermarking pipeline.")
    
    if st.button("Generate Audio File"):
        if not text_to_generate:
            st.warning("Please enter some text to generate.")
        else:
            with st.spinner("Generating audio..."):
                try:
                    # Save the speech to a file
                    tts_engine.save_to_file(text_to_generate, GENERATED_FILE)
                    tts_engine.runAndWait() # Wait for the file to be saved
                    
                    st.success(f"Audio file saved as `{GENERATED_FILE}`!")
                    st.audio(GENERATED_FILE, format='audio/wav')
                except Exception as e:
                    st.error(f"Error generating audio: {e}")

# --- TAB 2: EMBED WATERMARK ---
with tab2:
    st.header("Embed Watermark into Generated Audio")
    
    # Check if the generated file exists
    if not os.path.exists(GENERATED_FILE):
        st.warning(f"No audio file found. Please go to 'STEP 1: Generate Audio' and create `{GENERATED_FILE}` first.")
    else:
        st.info(f"Ready to watermark `{GENERATED_FILE}`.")
        st.audio(GENERATED_FILE, format='audio/wav')
        
        if st.button("Embed Watermark"):
            with st.spinner("Processing audio and embedding watermark..."):
                try:
                    # --- 1. Load & Pre-process Audio ---
                    wav, sample_rate = sf.read(GENERATED_FILE)
                    wav_tensor = preprocess_audio(wav, sample_rate)

                    # --- 2. Generate Metadata (Fully Automatic) ---
                    ai_models = ['ChatGPT', 'Gemini', 'Perplexity', 'Sora', 'pyttsx3']
                    message_id = random.randint(0, 65535)
                    message_id_hex = hex(message_id)
                    source = random.choice(ai_models)
                    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    metadata_string = f"Message embedded at {timestamp} to audio generated by {source}"
                    bit_string = f'{message_id:016b}'
                    
                    new_bits_list = [int(bit) for bit in bit_string] 
                    new_bits = [new_bits_list] 
                    message = torch.tensor(new_bits, dtype=torch.int32)
                    
                    st.info(f"Generated ID: {message_id} (Hex: {message_id_hex}) | Source: {source}")
                    
                    # --- 3. Embed Watermark ---
                    watermark = generator.get_watermark(wav_tensor, message=message, sample_rate=16000)
                    watermarked_audio = wav_tensor + watermark

                    # --- 4. Save Audio File (In Memory) ---
                    buffer = io.BytesIO()
                    watermarked_numpy = watermarked_audio.detach().cpu().numpy().squeeze()
                    sf.write(buffer, watermarked_numpy, 16000, format='WAV')
                    buffer.seek(0) # Rewind buffer

                    # --- 5. Save Metadata to Log ---
                    with open('metadata_log.csv', 'a', newline='') as f:
                        writer = csv.writer(f)
                        writer.writerow([message_id, metadata_string])

                    # --- 6. Show Success & Download Button ---
                    st.success(f"Success! Watermark embedded. Ready to download.")
                    st.download_button(
                        label="Download Watermarked File",
                        data=buffer,
                        file_name=WATERMARKED_FILE,
                        mime="audio/wav"
                    )

                except Exception as e:
                    st.error(f"Error: {e}")

# --- TAB 3: DETECT WATERMARK ---
with tab3:
    st.header("Detect Watermark")
    
    # File Uploader
    uploaded_file_detect = st.file_uploader("Upload an audio file to check (.wav)", type=["wav"], key="detect_uploader")
    
    if uploaded_file_detect is not None:
        st.audio(uploaded_file_detect, format='audio/wav')
        
        if st.button("Detect Watermark"):
            with st.spinner("Scanning file for watermark..."):
                try:
                    # --- 1. Load & Pre-process Audio ---
                    wav, sample_rate = sf.read(uploaded_file_detect)
                    wav_tensor = preprocess_audio(wav, sample_rate)

                    # --- 2. Detect Watermark ---
                    result, decoded_message = detector.detect_watermark(wav_tensor, sample_rate=16000)

                    # --- 3. Show Results ---
                    st.subheader("--- DETECTION RESULTS ---")
                    
                    if result > 0.5:
                        st.success(f"Watermark Detected: True (Confidence: {result:.4f})")
                        
                        bit_list = decoded_message.numpy().squeeze().tolist()
                        bit_string = "".join(map(str, bit_list))
                        message_id = int(bit_string, 2)
                        st.info(f"Decoded Message ID: {message_id} (Bits: {bit_string})")

                        # --- 4. Look up ID in Metadata Log ---
                        try:
                            found_metadata = False
                            with open('metadata_log.csv', 'r') as f:
                                reader = csv.reader(f)
                                for row in reader:
                                    if row and row[0] == str(message_id):
                                        st.info(f"Full Metadata: {row[1]}")
                                        found_metadata = True
                                        break
                            if not found_metadata:
                                st.warning(f"Found ID {message_id}, but no metadata was found in 'metadata_log.csv'.")
                        except FileNotFoundError:
                            st.warning("Could not find 'metadata_log.csv' to look up ID.")
                    
                    else:
                        st.error(f"Watermark Detected: False (Confidence: {result:.4f})")
                        st.info("No watermark detected. No message to decode.")

                except Exception as e:
                    st.error(f"Error: {e}")
